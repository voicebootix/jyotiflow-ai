const { Client } = require('pg');
const fs = require('fs').promises;
const path = require('path');

// Load environment variables
const DATABASE_URL = process.env.DATABASE_URL || 'postgresql://user:password@localhost:5432/yourdb';

const client = new Client({
  connectionString: DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

// AUTO-GENERATED BY CURSOR ANALYSIS - DO NOT EDIT
const SCHEMA_REQUIREMENTS = {
  users: {
    columns: {
      id: { type: 'SERIAL PRIMARY KEY', required: true },
      email: { type: 'VARCHAR(255) UNIQUE NOT NULL', required: true },
      password_hash: { type: 'VARCHAR(255) NOT NULL', required: true },
      name: { type: 'VARCHAR(255) NOT NULL', required: true },
      role: { type: 'VARCHAR(50) DEFAULT \'user\'', required: false },
      credits: { type: 'INTEGER DEFAULT 0', required: false },
      base_credits: { type: 'INTEGER DEFAULT 0', required: false },
      phone: { type: 'VARCHAR(20)', required: false },
      birth_date: { type: 'DATE', required: false },
      birth_time: { type: 'TIME', required: false },
      birth_location: { type: 'VARCHAR(255)', required: false },
      spiritual_level: { type: 'VARCHAR(50) DEFAULT \'beginner\'', required: false },
      preferred_language: { type: 'VARCHAR(10) DEFAULT \'en\'', required: false },
      avatar_sessions_count: { type: 'INTEGER DEFAULT 0', required: false },
      total_avatar_minutes: { type: 'INTEGER DEFAULT 0', required: false },
      created_at: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false },
      updated_at: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false },
      last_login_at: { type: 'TIMESTAMP', required: false }
    },
    found_in: ['auth.py', 'ai.py', 'core_foundation.py', 'auth_helpers.py']
  },
  sessions: {
    columns: {
      id: { type: 'SERIAL PRIMARY KEY', required: true },
      session_id: { type: 'VARCHAR(255) UNIQUE NOT NULL', required: true },
      user_email: { type: 'VARCHAR(255)', required: true },
      user_id: { type: 'INTEGER', required: false }, // Changed from TEXT to INTEGER
      service_type: { type: 'TEXT NOT NULL', required: true },
      duration_minutes: { type: 'INTEGER DEFAULT 0', required: false },
      credits_used: { type: 'INTEGER DEFAULT 0', required: false },
      session_data: { type: 'TEXT', required: false },
      question: { type: 'TEXT', required: false },
      birth_details: { type: 'JSONB', required: false },
      status: { type: 'VARCHAR(50) DEFAULT \'active\'', required: false },
      result_summary: { type: 'TEXT', required: false },
      full_result: { type: 'TEXT', required: false },
      guidance: { type: 'TEXT', required: false },
      avatar_video_url: { type: 'VARCHAR(500)', required: false },
      follow_up_email_sent: { type: 'BOOLEAN DEFAULT FALSE', required: false },
      follow_up_sms_sent: { type: 'BOOLEAN DEFAULT FALSE', required: false },
      follow_up_whatsapp_sent: { type: 'BOOLEAN DEFAULT FALSE', required: false },
      created_at: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false },
      updated_at: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false }
    },
    found_in: ['sessions.py', 'followup.py', 'ai.py', 'spiritual.py']
  },
  service_types: {
    columns: {
      id: { type: 'SERIAL PRIMARY KEY', required: true },
      name: { type: 'VARCHAR(100) UNIQUE NOT NULL', required: true },
      display_name: { type: 'VARCHAR(255)', required: false },
      description: { type: 'TEXT', required: false },
      base_credits: { type: 'INTEGER NOT NULL DEFAULT 10', required: true },
      credits_required: { type: 'INTEGER DEFAULT 5', required: true }, // Critical missing column
      price_usd: { type: 'DECIMAL(10,2) DEFAULT 0.0', required: false },
      duration_minutes: { type: 'INTEGER DEFAULT 15', required: false },
      video_enabled: { type: 'BOOLEAN DEFAULT true', required: false },
      service_category: { type: 'VARCHAR(100) DEFAULT \'guidance\'', required: false },
      enabled: { type: 'BOOLEAN DEFAULT true', required: false },
      icon: { type: 'VARCHAR(50) DEFAULT \'🔮\'', required: false },
      created_at: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false },
      updated_at: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false }
    },
    found_in: ['services.py', 'ai.py', 'startup_database_validator.py']
  },
  // Missing tables that need to be created
  user_subscriptions: {
    columns: {
      id: { type: 'SERIAL PRIMARY KEY', required: true },
      user_email: { type: 'VARCHAR(255) NOT NULL', required: true },
      subscription_tier: { type: 'VARCHAR(50) NOT NULL', required: true },
      stripe_subscription_id: { type: 'VARCHAR(255)', required: false },
      status: { type: 'VARCHAR(50) DEFAULT \'active\'', required: false },
      current_period_start: { type: 'TIMESTAMP', required: false },
      current_period_end: { type: 'TIMESTAMP', required: false },
      created_at: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false },
      updated_at: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false }
    },
    found_in: ['init_database.py']
  },
  satsang_events: {
    columns: {
      id: { type: 'SERIAL PRIMARY KEY', required: true },
      title: { type: 'VARCHAR(255) NOT NULL', required: true },
      description: { type: 'TEXT', required: false },
      event_date: { type: 'DATE NOT NULL', required: true },
      event_time: { type: 'TIME NOT NULL', required: true },
      duration_minutes: { type: 'INTEGER DEFAULT 60', required: false },
      max_attendees: { type: 'INTEGER DEFAULT 100', required: false },
      is_online: { type: 'BOOLEAN DEFAULT true', required: false },
      meeting_link: { type: 'VARCHAR(500)', required: false },
      created_at: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false }
    },
    found_in: ['core_foundation.py']
  },
  satsang_attendees: {
    columns: {
      id: { type: 'SERIAL PRIMARY KEY', required: true },
      satsang_id: { type: 'INTEGER REFERENCES satsang_events(id)', required: true },
      user_email: { type: 'VARCHAR(255) NOT NULL', required: true },
      registration_date: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false },
      attended: { type: 'BOOLEAN DEFAULT false', required: false }
    },
    found_in: ['core_foundation.py']
  },
  social_content: {
    columns: {
      id: { type: 'SERIAL PRIMARY KEY', required: true },
      content_type: { type: 'VARCHAR(50) NOT NULL', required: true },
      platform: { type: 'VARCHAR(50) NOT NULL', required: true },
      content_text: { type: 'TEXT', required: false },
      media_urls: { type: 'JSONB DEFAULT \'[]\'', required: false },
      hashtags: { type: 'JSONB DEFAULT \'[]\'', required: false },
      scheduled_time: { type: 'TIMESTAMP', required: false },
      posted: { type: 'BOOLEAN DEFAULT false', required: false },
      source_user_email: { type: 'VARCHAR(255)', required: false },
      created_at: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false }
    },
    found_in: ['core_foundation.py']
  },
  birth_chart_cache: {
    columns: {
      id: { type: 'SERIAL PRIMARY KEY', required: true },
      user_email: { type: 'VARCHAR(255) NOT NULL', required: true },
      birth_details_hash: { type: 'VARCHAR(64) UNIQUE NOT NULL', required: true },
      chart_data: { type: 'JSONB NOT NULL', required: true },
      created_at: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false },
      expires_at: { type: 'TIMESTAMP', required: false }
    },
    found_in: ['run_birth_chart_cache_migration.py']
  },
  prokerala_tokens: {
    columns: {
      id: { type: 'SERIAL PRIMARY KEY', required: true },
      token_type: { type: 'VARCHAR(50) NOT NULL', required: true },
      access_token: { type: 'TEXT NOT NULL', required: true },
      expires_at: { type: 'TIMESTAMP NOT NULL', required: true },
      created_at: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false }
    },
    found_in: ['add_prokerala_smart_pricing.sql']
  }
};

const TYPE_CONVERSIONS = {
  // Critical: Fix user_id type mismatch in sessions table
  sessions: {
    user_id: {
      from: 'TEXT',
      to: 'INTEGER',
      conversion: 'USING NULLIF(user_id, \'\')::INTEGER',
      validation: 'WHERE user_id IS NULL OR user_id ~ \'^[0-9]+$\'',
      backup_first: true
    }
  }
};

const UNUSED_COLUMNS = {
  sessions: ['aud', 'role', 'instance_id'], // Supabase-specific columns not used in code
};

const UNUSED_MIGRATIONS = [
  'backend/migrations/add_pricing_tables.sql', // Duplicate of add_missing_pricing_tables.sql
  'backend/migrations/add_prokerala_smart_pricing.sql', // Tables not used in code
];

async function fixDatabase() {
  try {
    await client.connect();
    console.log('🔧 Starting comprehensive database fix...\n');
    
    // Step 1: Create missing tables
    console.log('📦 Creating missing tables...');
    for (const [tableName, schema] of Object.entries(SCHEMA_REQUIREMENTS)) {
      const exists = await tableExists(tableName);
      if (!exists) {
        await createTable(tableName, schema);
      }
    }
    
    // Step 2: Fix type mismatches
    console.log('\n🔄 Fixing type mismatches...');
    for (const [table, conversions] of Object.entries(TYPE_CONVERSIONS)) {
      for (const [column, conversion] of Object.entries(conversions)) {
        await fixColumnType(table, column, conversion);
      }
    }
    
    // Step 3: Add missing columns
    console.log('\n➕ Adding missing columns...');
    for (const [table, schema] of Object.entries(SCHEMA_REQUIREMENTS)) {
      if (await tableExists(table)) {
        await addMissingColumns(table, schema.columns);
      }
    }
    
    // Step 4: Remove unused columns (optional - comment out if unsure)
    console.log('\n🧹 Removing unused columns...');
    for (const [table, columns] of Object.entries(UNUSED_COLUMNS)) {
      if (await tableExists(table)) {
        await removeUnusedColumns(table, columns);
      }
    }
    
    // Step 5: Clean up migration files
    console.log('\n📁 Cleaning migration files...');
    await cleanupMigrations();
    
    // Step 6: Add foreign key constraints where missing
    console.log('\n🔗 Adding foreign key constraints...');
    await addForeignKeyConstraints();
    
    console.log('\n✅ Database fixed successfully!');
    
  } catch (error) {
    console.error('❌ Error:', error);
  } finally {
    await client.end();
  }
}

async function tableExists(tableName) {
  const result = await client.query(
    'SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_name = $1)',
    [tableName]
  );
  return result.rows[0].exists;
}

async function columnExists(tableName, columnName) {
  const result = await client.query(
    'SELECT EXISTS (SELECT FROM information_schema.columns WHERE table_name = $1 AND column_name = $2)',
    [tableName, columnName]
  );
  return result.rows[0].exists;
}

async function createTable(tableName, schema) {
  const columns = Object.entries(schema.columns)
    .map(([name, def]) => `${name} ${def.type}`)
    .join(', ');
  
  try {
    await client.query(`CREATE TABLE ${tableName} (${columns})`);
    console.log(`  ✅ Created table: ${tableName}`);
  } catch (error) {
    console.log(`  ⚠️  Failed to create table ${tableName}: ${error.message}`);
  }
}

async function addMissingColumns(tableName, requiredColumns) {
  for (const [columnName, def] of Object.entries(requiredColumns)) {
    const exists = await columnExists(tableName, columnName);
    if (!exists) {
      try {
        await client.query(`ALTER TABLE ${tableName} ADD COLUMN ${columnName} ${def.type}`);
        console.log(`  ✅ Added column: ${tableName}.${columnName}`);
      } catch (error) {
        console.log(`  ⚠️  Failed to add column ${tableName}.${columnName}: ${error.message}`);
      }
    }
  }
}

async function fixColumnType(table, column, conversion) {
  try {
    console.log(`  Converting ${table}.${column} from ${conversion.from} to ${conversion.to}`);
    
    // Check if column exists
    if (!await columnExists(table, column)) {
      console.log(`  ⚠️  Column ${table}.${column} does not exist, skipping conversion`);
      return;
    }
    
    // Create backup column
    if (conversion.backup_first) {
      const backupColumn = `${column}_backup`;
      if (!await columnExists(table, backupColumn)) {
        await client.query(`ALTER TABLE ${table} ADD COLUMN ${backupColumn} ${conversion.from}`);
        await client.query(`UPDATE ${table} SET ${backupColumn} = ${column}`);
        console.log(`  📦 Created backup column: ${backupColumn}`);
      }
    }
    
    // Convert type
    if (conversion.validation) {
      // Only convert valid data
      await client.query(`
        UPDATE ${table} 
        SET ${column} = NULL 
        WHERE ${column} IS NOT NULL 
        AND NOT (${column} ~ '^[0-9]+$')
      `);
    }
    
    await client.query(`
      ALTER TABLE ${table} 
      ALTER COLUMN ${column} TYPE ${conversion.to} 
      ${conversion.conversion}
    `);
    
    console.log(`  ✅ Converted successfully`);
  } catch (error) {
    console.log(`  ⚠️  Failed to convert: ${error.message}`);
  }
}

async function removeUnusedColumns(tableName, columns) {
  // Create backup table first
  const backupName = `${tableName}_backup_${new Date().toISOString().split('T')[0].replace(/-/g, '_')}`;
  
  try {
    await client.query(`CREATE TABLE ${backupName} AS SELECT * FROM ${tableName}`);
    console.log(`  📦 Created backup table: ${backupName}`);
    
    for (const column of columns) {
      if (await columnExists(tableName, column)) {
        await client.query(`ALTER TABLE ${tableName} DROP COLUMN IF EXISTS ${column}`);
        console.log(`  ❌ Removed: ${tableName}.${column}`);
      }
    }
  } catch (error) {
    console.log(`  ⚠️  Failed to remove columns from ${tableName}: ${error.message}`);
  }
}

async function cleanupMigrations() {
  for (const migrationFile of UNUSED_MIGRATIONS) {
    try {
      const backupDir = path.join(path.dirname(migrationFile), 'archived');
      await fs.mkdir(backupDir, { recursive: true });
      
      const fileName = path.basename(migrationFile);
      const backupPath = path.join(backupDir, `${Date.now()}_${fileName}`);
      
      // Check if file exists before moving
      try {
        await fs.access(migrationFile);
        await fs.rename(migrationFile, backupPath);
        console.log(`  📦 Archived: ${migrationFile} → ${backupPath}`);
      } catch (error) {
        console.log(`  ⚠️  Migration file not found: ${migrationFile}`);
      }
    } catch (error) {
      console.log(`  ⚠️  Failed to archive ${migrationFile}: ${error.message}`);
    }
  }
}

async function addForeignKeyConstraints() {
  const constraints = [
    {
      table: 'sessions',
      constraint: 'fk_sessions_user',
      definition: 'FOREIGN KEY (user_email) REFERENCES users(email) ON DELETE CASCADE'
    },
    {
      table: 'satsang_attendees',
      constraint: 'fk_attendees_event',
      definition: 'FOREIGN KEY (satsang_id) REFERENCES satsang_events(id) ON DELETE CASCADE'
    },
    {
      table: 'user_subscriptions',
      constraint: 'fk_subscriptions_user',
      definition: 'FOREIGN KEY (user_email) REFERENCES users(email) ON DELETE CASCADE'
    }
  ];
  
  for (const { table, constraint, definition } of constraints) {
    if (await tableExists(table)) {
      try {
        // Check if constraint already exists
        const constraintExists = await client.query(
          `SELECT 1 FROM information_schema.table_constraints 
           WHERE constraint_name = $1 AND table_name = $2`,
          [constraint, table]
        );
        
        if (!constraintExists.rows.length) {
          await client.query(`ALTER TABLE ${table} ADD CONSTRAINT ${constraint} ${definition}`);
          console.log(`  ✅ Added constraint: ${constraint} on ${table}`);
        }
      } catch (error) {
        console.log(`  ⚠️  Failed to add constraint ${constraint}: ${error.message}`);
      }
    }
  }
}

// Run the fix
fixDatabase();