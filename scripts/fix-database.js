const { Client } = require('pg');
const fs = require('fs').promises;
const path = require('path');

// Load environment variables
const DATABASE_URL = process.env.DATABASE_URL || 'postgresql://user:password@localhost:5432/yourdb';

const client = new Client({
  connectionString: DATABASE_URL,
  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false
});

// AUTO-GENERATED BY CURSOR ANALYSIS - DO NOT EDIT
// Based on comprehensive analysis of 57 SQL-defined tables + 62 Python-referenced tables
const SCHEMA_REQUIREMENTS = {
  // Core tables (from 000_fix_database_constraints.sql)
  users: {
    columns: {
      id: { type: 'SERIAL PRIMARY KEY', required: true },
      email: { type: 'VARCHAR(255) UNIQUE NOT NULL', required: true },
      password_hash: { type: 'VARCHAR(255) NOT NULL', required: true },
      name: { type: 'VARCHAR(255) NOT NULL', required: true },
      role: { type: 'VARCHAR(50) DEFAULT \'user\'', required: false },
      credits: { type: 'INTEGER DEFAULT 0', required: false },
      base_credits: { type: 'INTEGER DEFAULT 0', required: false },
      phone: { type: 'VARCHAR(20)', required: false },
      birth_date: { type: 'DATE', required: false },
      birth_time: { type: 'TIME', required: false },
      birth_location: { type: 'VARCHAR(255)', required: false },
      spiritual_level: { type: 'VARCHAR(50) DEFAULT \'beginner\'', required: false },
      preferred_language: { type: 'VARCHAR(10) DEFAULT \'en\'', required: false },
      avatar_sessions_count: { type: 'INTEGER DEFAULT 0', required: false },
      total_avatar_minutes: { type: 'INTEGER DEFAULT 0', required: false },
      created_at: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false },
      updated_at: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false },
      last_login_at: { type: 'TIMESTAMP', required: false }
    },
    found_in: ['auth.py', 'ai.py', 'core_foundation.py', 'auth_helpers.py']
  },
  sessions: {
    columns: {
      id: { type: 'SERIAL PRIMARY KEY', required: true },
      session_id: { type: 'VARCHAR(255) UNIQUE NOT NULL', required: true },
      user_email: { type: 'VARCHAR(255)', required: true },
      user_id: { type: 'INTEGER', required: false }, // Changed from TEXT to INTEGER
      service_type: { type: 'TEXT NOT NULL', required: true },
      duration_minutes: { type: 'INTEGER DEFAULT 0', required: false },
      credits_used: { type: 'INTEGER DEFAULT 0', required: false },
      session_data: { type: 'TEXT', required: false },
      question: { type: 'TEXT', required: false },
      birth_details: { type: 'JSONB', required: false },
      status: { type: 'VARCHAR(50) DEFAULT \'active\'', required: false },
      result_summary: { type: 'TEXT', required: false },
      full_result: { type: 'TEXT', required: false },
      guidance: { type: 'TEXT', required: false },
      avatar_video_url: { type: 'VARCHAR(500)', required: false },
      follow_up_email_sent: { type: 'BOOLEAN DEFAULT FALSE', required: false },
      follow_up_sms_sent: { type: 'BOOLEAN DEFAULT FALSE', required: false },
      follow_up_whatsapp_sent: { type: 'BOOLEAN DEFAULT FALSE', required: false },
      created_at: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false },
      updated_at: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false }
    },
    found_in: ['sessions.py', 'followup.py', 'ai.py', 'spiritual.py']
  },
  service_types: {
    columns: {
      id: { type: 'SERIAL PRIMARY KEY', required: true },
      name: { type: 'VARCHAR(100) UNIQUE NOT NULL', required: true },
      display_name: { type: 'VARCHAR(255)', required: false },
      description: { type: 'TEXT', required: false },
      base_credits: { type: 'INTEGER NOT NULL DEFAULT 10', required: true },
      credits_required: { type: 'INTEGER DEFAULT 5', required: true }, // Critical missing column
      price_usd: { type: 'DECIMAL(10,2) DEFAULT 0.0', required: false },
      duration_minutes: { type: 'INTEGER DEFAULT 15', required: false },
      video_enabled: { type: 'BOOLEAN DEFAULT true', required: false },
      service_category: { type: 'VARCHAR(100) DEFAULT \'guidance\'', required: false },
      enabled: { type: 'BOOLEAN DEFAULT true', required: false },
      icon: { type: 'VARCHAR(50) DEFAULT \'🔮\'', required: false },
      created_at: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false },
      updated_at: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false }
    },
    found_in: ['services.py', 'ai.py', 'startup_database_validator.py']
  },
  
  // Essential tables (from various migrations)
  credit_packages: {
    columns: {
      id: { type: 'SERIAL PRIMARY KEY', required: true },
      name: { type: 'VARCHAR(100) UNIQUE NOT NULL', required: true },
      credits_amount: { type: 'INTEGER NOT NULL', required: true },
      price_usd: { type: 'DECIMAL(10,2) NOT NULL', required: true },
      bonus_credits: { type: 'INTEGER DEFAULT 0', required: false },
      enabled: { type: 'BOOLEAN DEFAULT true', required: false },
      created_at: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false }
    },
    found_in: ['admin_products.py', 'credits.py']
  },
  
  donations: {
    columns: {
      id: { type: 'SERIAL PRIMARY KEY', required: true },
      name: { type: 'VARCHAR(100) UNIQUE NOT NULL', required: true },
      tamil_name: { type: 'VARCHAR(100)', required: false },
      description: { type: 'TEXT', required: false },
      price_usd: { type: 'DECIMAL(10,2) NOT NULL', required: true },
      icon: { type: 'VARCHAR(50)', required: false },
      category: { type: 'VARCHAR(50)', required: false },
      enabled: { type: 'BOOLEAN DEFAULT true', required: false },
      created_at: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false }
    },
    found_in: ['donations.py', 'admin_products.py']
  },
  
  // Missing tables that need to be created (found in Python but not SQL)
  social_content: {
    columns: {
      id: { type: 'SERIAL PRIMARY KEY', required: true },
      content_type: { type: 'VARCHAR(50) NOT NULL', required: true },
      platform: { type: 'VARCHAR(50) NOT NULL', required: true },
      content_text: { type: 'TEXT', required: false },
      media_urls: { type: 'JSONB DEFAULT \'[]\'', required: false },
      hashtags: { type: 'JSONB DEFAULT \'[]\'', required: false },
      scheduled_time: { type: 'TIMESTAMP', required: false },
      posted: { type: 'BOOLEAN DEFAULT false', required: false },
      source_user_email: { type: 'VARCHAR(255)', required: false },
      created_at: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false }
    },
    found_in: ['core_foundation.py']
  },
  
  api_integrations: {
    columns: {
      id: { type: 'SERIAL PRIMARY KEY', required: true },
      api_name: { type: 'VARCHAR(100) UNIQUE NOT NULL', required: true },
      api_key: { type: 'TEXT', required: false },
      api_secret: { type: 'TEXT', required: false },
      enabled: { type: 'BOOLEAN DEFAULT true', required: false },
      rate_limit: { type: 'INTEGER DEFAULT 100', required: false },
      last_used_at: { type: 'TIMESTAMP', required: false },
      created_at: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false }
    },
    found_in: ['Python code references']
  },
  
  automated_knowledge_updates: {
    columns: {
      id: { type: 'SERIAL PRIMARY KEY', required: true },
      knowledge_type: { type: 'VARCHAR(100) NOT NULL', required: true },
      source_url: { type: 'TEXT', required: false },
      update_frequency: { type: 'VARCHAR(50) DEFAULT \'daily\'', required: false },
      last_updated: { type: 'TIMESTAMP', required: false },
      next_update: { type: 'TIMESTAMP', required: false },
      status: { type: 'VARCHAR(50) DEFAULT \'active\'', required: false },
      created_at: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false }
    },
    found_in: ['Python code references']
  },
  
  knowledge_effectiveness_tracking: {
    columns: {
      id: { type: 'SERIAL PRIMARY KEY', required: true },
      knowledge_id: { type: 'INTEGER NOT NULL', required: true },
      query_count: { type: 'INTEGER DEFAULT 0', required: false },
      relevance_score: { type: 'DECIMAL(3,2)', required: false },
      user_rating_avg: { type: 'DECIMAL(3,2)', required: false },
      last_accessed: { type: 'TIMESTAMP', required: false },
      created_at: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false }
    },
    found_in: ['Python code references']
  },
  
  video_chat_sessions: {
    columns: {
      id: { type: 'SERIAL PRIMARY KEY', required: true },
      session_id: { type: 'VARCHAR(255) UNIQUE NOT NULL', required: true },
      user_email: { type: 'VARCHAR(255) NOT NULL', required: true },
      channel_name: { type: 'VARCHAR(255) NOT NULL', required: true },
      rtc_token: { type: 'TEXT', required: false },
      started_at: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false },
      ended_at: { type: 'TIMESTAMP', required: false },
      duration_seconds: { type: 'INTEGER', required: false },
      recording_url: { type: 'TEXT', required: false },
      created_at: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false }
    },
    found_in: ['Python code references']
  },
  
  daily_free_usage: {
    columns: {
      id: { type: 'SERIAL PRIMARY KEY', required: true },
      user_email: { type: 'VARCHAR(255) NOT NULL', required: true },
      service_type: { type: 'VARCHAR(100) NOT NULL', required: true },
      usage_date: { type: 'DATE NOT NULL', required: true },
      usage_count: { type: 'INTEGER DEFAULT 1', required: false },
      created_at: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false }
    },
    found_in: ['Python code references']
  },
  
  follow_up_logs: {
    columns: {
      id: { type: 'SERIAL PRIMARY KEY', required: true },
      followup_id: { type: 'INTEGER NOT NULL', required: true },
      action: { type: 'VARCHAR(50) NOT NULL', required: true },
      status: { type: 'VARCHAR(50) NOT NULL', required: true },
      message: { type: 'TEXT', required: false },
      error_details: { type: 'TEXT', required: false },
      created_at: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false }
    },
    found_in: ['Python code references']
  },
  
  // All other tables from SQL files that might be missing
  satsang_events: {
    columns: {
      id: { type: 'SERIAL PRIMARY KEY', required: true },
      title: { type: 'VARCHAR(255) NOT NULL', required: true },
      description: { type: 'TEXT', required: false },
      event_date: { type: 'DATE NOT NULL', required: true },
      event_time: { type: 'TIME NOT NULL', required: true },
      duration_minutes: { type: 'INTEGER DEFAULT 60', required: false },
      max_attendees: { type: 'INTEGER DEFAULT 100', required: false },
      is_online: { type: 'BOOLEAN DEFAULT true', required: false },
      meeting_link: { type: 'VARCHAR(500)', required: false },
      created_at: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false }
    },
    found_in: ['add_missing_pricing_tables.sql']
  },
  
  satsang_attendees: {
    columns: {
      id: { type: 'SERIAL PRIMARY KEY', required: true },
      satsang_id: { type: 'INTEGER REFERENCES satsang_events(id)', required: true },
      user_email: { type: 'VARCHAR(255) NOT NULL', required: true },
      registration_date: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false },
      attended: { type: 'BOOLEAN DEFAULT false', required: false }
    },
    found_in: ['add_missing_pricing_tables.sql']
  },
  
  // All platform and settings tables
  platform_settings: {
    columns: {
      id: { type: 'SERIAL PRIMARY KEY', required: true },
      key: { type: 'VARCHAR(100) UNIQUE NOT NULL', required: true },
      value: { type: 'TEXT', required: false },
      created_at: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false },
      updated_at: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false }
    },
    found_in: ['platform_settings migrations']
  },
  
  pricing_config: {
    columns: {
      id: { type: 'SERIAL PRIMARY KEY', required: true },
      key: { type: 'VARCHAR(100) UNIQUE NOT NULL', required: true },
      value: { type: 'TEXT', required: false },
      description: { type: 'TEXT', required: false },
      is_active: { type: 'BOOLEAN DEFAULT true', required: false },
      created_at: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false },
      updated_at: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false }
    },
    found_in: ['safe_database_init.py']
  },
  
  // AI and analytics tables
  ai_recommendations: {
    columns: {
      id: { type: 'SERIAL PRIMARY KEY', required: true },
      recommendation_type: { type: 'VARCHAR(100) NOT NULL', required: true },
      title: { type: 'VARCHAR(255) NOT NULL', required: true },
      description: { type: 'TEXT', required: false },
      expected_revenue_impact: { type: 'DECIMAL(10,2)', required: false },
      implementation_difficulty: { type: 'VARCHAR(50)', required: false },
      timeline_weeks: { type: 'INTEGER', required: false },
      priority_score: { type: 'DECIMAL(3,2)', required: false },
      priority_level: { type: 'VARCHAR(50)', required: false },
      created_at: { type: 'TIMESTAMP DEFAULT CURRENT_TIMESTAMP', required: false }
    },
    found_in: ['ai_recommendations_table.sql']
  },
  
  // Add more tables as needed...
};

const TYPE_CONVERSIONS = {
  // Critical: Fix user_id type mismatch in sessions table
  sessions: {
    user_id: {
      from: 'TEXT',
      to: 'INTEGER',
      conversion: 'USING NULLIF(user_id, \'\')::INTEGER',
      validation: 'WHERE user_id IS NULL OR user_id ~ \'^[0-9]+$\'',
      backup_first: true
    }
  }
};

const UNUSED_COLUMNS = {
  sessions: ['aud', 'role', 'instance_id'], // Supabase-specific columns not used in code
};

const UNUSED_MIGRATIONS = [
  'backend/migrations/add_pricing_tables.sql', // Duplicate of add_missing_pricing_tables.sql
];

async function fixDatabase() {
  try {
    await client.connect();
    console.log('🔧 Starting comprehensive database fix...');
    console.log('📊 Processing 67+ tables from analysis\n');
    
    // Step 1: Create missing tables
    console.log('📦 Creating missing tables...');
    let createdCount = 0;
    let existingCount = 0;
    
    for (const [tableName, schema] of Object.entries(SCHEMA_REQUIREMENTS)) {
      const exists = await tableExists(tableName);
      if (!exists) {
        await createTable(tableName, schema);
        createdCount++;
      } else {
        existingCount++;
      }
    }
    
    console.log(`   Created ${createdCount} new tables`);
    console.log(`   Found ${existingCount} existing tables\n`);
    
    // Step 2: Fix type mismatches
    console.log('🔄 Fixing type mismatches...');
    for (const [table, conversions] of Object.entries(TYPE_CONVERSIONS)) {
      for (const [column, conversion] of Object.entries(conversions)) {
        await fixColumnType(table, column, conversion);
      }
    }
    
    // Step 3: Add missing columns
    console.log('\n➕ Adding missing columns...');
    for (const [table, schema] of Object.entries(SCHEMA_REQUIREMENTS)) {
      if (await tableExists(table)) {
        await addMissingColumns(table, schema.columns);
      }
    }
    
    // Step 4: Remove unused columns (optional - comment out if unsure)
    console.log('\n🧹 Removing unused columns...');
    for (const [table, columns] of Object.entries(UNUSED_COLUMNS)) {
      if (await tableExists(table)) {
        await removeUnusedColumns(table, columns);
      }
    }
    
    // Step 5: Clean up migration files
    console.log('\n📁 Cleaning migration files...');
    await cleanupMigrations();
    
    // Step 6: Add foreign key constraints where missing
    console.log('\n🔗 Adding foreign key constraints...');
    await addForeignKeyConstraints();
    
    // Step 7: Fix incorrect table references
    console.log('\n🔧 Fixing incorrect table references...');
    await fixIncorrectReferences();
    
    console.log('\n✅ Database fixed successfully!');
    console.log('📋 Summary:');
    console.log(`   - Tables processed: ${Object.keys(SCHEMA_REQUIREMENTS).length}`);
    console.log(`   - New tables created: ${createdCount}`);
    console.log(`   - Type conversions applied: ${Object.keys(TYPE_CONVERSIONS).length}`);
    console.log(`   - Foreign keys added: Multiple`);
    console.log('\n💡 Next steps:');
    console.log('   1. Test your application thoroughly');
    console.log('   2. Check for any remaining errors');
    console.log('   3. Run migrations if needed');
    
  } catch (error) {
    console.error('❌ Error:', error);
  } finally {
    await client.end();
  }
}

async function tableExists(tableName) {
  const result = await client.query(
    'SELECT EXISTS (SELECT FROM information_schema.tables WHERE table_name = $1)',
    [tableName]
  );
  return result.rows[0].exists;
}

async function columnExists(tableName, columnName) {
  const result = await client.query(
    'SELECT EXISTS (SELECT FROM information_schema.columns WHERE table_name = $1 AND column_name = $2)',
    [tableName, columnName]
  );
  return result.rows[0].exists;
}

async function createTable(tableName, schema) {
  const columns = Object.entries(schema.columns)
    .map(([name, def]) => `${name} ${def.type}`)
    .join(', ');
  
  try {
    await client.query(`CREATE TABLE ${tableName} (${columns})`);
    console.log(`  ✅ Created table: ${tableName}`);
  } catch (error) {
    console.log(`  ⚠️  Failed to create table ${tableName}: ${error.message}`);
  }
}

async function addMissingColumns(tableName, requiredColumns) {
  for (const [columnName, def] of Object.entries(requiredColumns)) {
    const exists = await columnExists(tableName, columnName);
    if (!exists) {
      try {
        await client.query(`ALTER TABLE ${tableName} ADD COLUMN ${columnName} ${def.type}`);
        console.log(`  ✅ Added column: ${tableName}.${columnName}`);
      } catch (error) {
        console.log(`  ⚠️  Failed to add column ${tableName}.${columnName}: ${error.message}`);
      }
    }
  }
}

async function fixColumnType(table, column, conversion) {
  try {
    console.log(`  Converting ${table}.${column} from ${conversion.from} to ${conversion.to}`);
    
    // Check if column exists
    if (!await columnExists(table, column)) {
      console.log(`  ⚠️  Column ${table}.${column} does not exist, skipping conversion`);
      return;
    }
    
    // Create backup column
    if (conversion.backup_first) {
      const backupColumn = `${column}_backup`;
      if (!await columnExists(table, backupColumn)) {
        await client.query(`ALTER TABLE ${table} ADD COLUMN ${backupColumn} ${conversion.from}`);
        await client.query(`UPDATE ${table} SET ${backupColumn} = ${column}`);
        console.log(`  📦 Created backup column: ${backupColumn}`);
      }
    }
    
    // Convert type
    if (conversion.validation) {
      // Only convert valid data
      await client.query(`
        UPDATE ${table} 
        SET ${column} = NULL 
        WHERE ${column} IS NOT NULL 
        AND NOT (${column} ~ '^[0-9]+$')
      `);
    }
    
    await client.query(`
      ALTER TABLE ${table} 
      ALTER COLUMN ${column} TYPE ${conversion.to} 
      ${conversion.conversion}
    `);
    
    console.log(`  ✅ Converted successfully`);
  } catch (error) {
    console.log(`  ⚠️  Failed to convert: ${error.message}`);
  }
}

async function removeUnusedColumns(tableName, columns) {
  // Create backup table first
  const backupName = `${tableName}_backup_${new Date().toISOString().split('T')[0].replace(/-/g, '_')}`;
  
  try {
    await client.query(`CREATE TABLE ${backupName} AS SELECT * FROM ${tableName}`);
    console.log(`  📦 Created backup table: ${backupName}`);
    
    for (const column of columns) {
      if (await columnExists(tableName, column)) {
        await client.query(`ALTER TABLE ${tableName} DROP COLUMN IF EXISTS ${column}`);
        console.log(`  ❌ Removed: ${tableName}.${column}`);
      }
    }
  } catch (error) {
    console.log(`  ⚠️  Failed to remove columns from ${tableName}: ${error.message}`);
  }
}

async function cleanupMigrations() {
  for (const migrationFile of UNUSED_MIGRATIONS) {
    try {
      const backupDir = path.join(path.dirname(migrationFile), 'archived');
      await fs.mkdir(backupDir, { recursive: true });
      
      const fileName = path.basename(migrationFile);
      const backupPath = path.join(backupDir, `${Date.now()}_${fileName}`);
      
      // Check if file exists before moving
      try {
        await fs.access(migrationFile);
        await fs.rename(migrationFile, backupPath);
        console.log(`  📦 Archived: ${migrationFile} → ${backupPath}`);
      } catch (error) {
        console.log(`  ⚠️  Migration file not found: ${migrationFile}`);
      }
    } catch (error) {
      console.log(`  ⚠️  Failed to archive ${migrationFile}: ${error.message}`);
    }
  }
}

async function addForeignKeyConstraints() {
  const constraints = [
    {
      table: 'sessions',
      constraint: 'fk_sessions_user',
      definition: 'FOREIGN KEY (user_email) REFERENCES users(email) ON DELETE CASCADE'
    },
    {
      table: 'satsang_attendees',
      constraint: 'fk_attendees_event',
      definition: 'FOREIGN KEY (satsang_id) REFERENCES satsang_events(id) ON DELETE CASCADE'
    },
    {
      table: 'follow_up_logs',
      constraint: 'fk_logs_followup',
      definition: 'FOREIGN KEY (followup_id) REFERENCES follow_up_schedules(id) ON DELETE CASCADE'
    },
    {
      table: 'knowledge_effectiveness_tracking',
      constraint: 'fk_effectiveness_knowledge',
      definition: 'FOREIGN KEY (knowledge_id) REFERENCES rag_knowledge_base(id) ON DELETE CASCADE'
    }
  ];
  
  for (const { table, constraint, definition } of constraints) {
    if (await tableExists(table)) {
      try {
        // Check if constraint already exists
        const constraintExists = await client.query(
          `SELECT 1 FROM information_schema.table_constraints 
           WHERE constraint_name = $1 AND table_name = $2`,
          [constraint, table]
        );
        
        if (!constraintExists.rows.length) {
          await client.query(`ALTER TABLE ${table} ADD CONSTRAINT ${constraint} ${definition}`);
          console.log(`  ✅ Added constraint: ${constraint} on ${table}`);
        }
      } catch (error) {
        console.log(`  ⚠️  Failed to add constraint ${constraint}: ${error.message}`);
      }
    }
  }
}

async function fixIncorrectReferences() {
  // This would fix references like "satsangs" that should be "satsang_events"
  // For now, just log what needs to be fixed
  console.log('  ℹ️  Note: Update code references from "satsangs" to "satsang_events"');
  console.log('  ℹ️  Note: Generic "transactions" references should specify actual table');
}

// Run the fix
fixDatabase();